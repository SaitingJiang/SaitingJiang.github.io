[{"title":"java进阶-学习笔记(二)","slug":"java进阶-学习笔记(二)","url":"/2022/06/01/java-jin-jie-xue-xi-bi-ji-er/","content":"\n  **输入输出处理**  \n\n   什么是文件？  \n\n 相关记录或放在一起的数据的集合\n\n   Java    程序如何访问文件属性？  \n\n **JAVA API ：java.io.File 类**\n\nFile file = new File( String pathname );\n\n```java\nboolean exists( )            判断文件或目录是否存在\nboolean isFile( )            判断是否是文件\nboolean isDirectory( )       判断是否是目录\nString getPath( )            返回此对象表示的文件的相对路径名\nString getAbsolutePath( )    返回此对象表示的文件的绝对路径名\nString getName( )            返回此对象表示的文件或目录的名称\nboolean delete( )            删除此对象指定的文件或目录\nboolean createNewFile( )     创建名称的空文件，不创建文件夹\nlong  length()               返回文件的长度，单位为字节, 如果文件不存在，则返回 0L\n```\n\n   如何读写文件？  \n\n   通过流来读写文件  \n\n 流是一组有序的数据序列\n\n 以先进先出方式发送信息的通道\n\n   **Java    流的分类**  \n\n![图片 4](../images/java进阶-学习笔记(二)/图片 4.png)\n\n![图片 5](../images/java进阶-学习笔记(二)/图片 5.png)\n\n  输入输出流是相对于计算机内存来说的  \n\n  字节流是     8     位通用字节流，字符流是     16     位     Unicode     字符流  \n\n  **FileInputStream**  \n\n   **InputStream**    类常用方法  \n\nint read( )\n\nint read(byte[] b)\n\nint read(byte[] b,int off,int len)\n\nvoid close( )\n\nint available()：可以从输入流中读取的字节数目\n\n   **子类    FileInputStream**    常用的构造方法  \n\n  FileInputStream(File file)\n\nFileInputStream(String name) \n\n  **使用FileInputStream 读文本文件**  \n\n![6](../images/java进阶-学习笔记(二)/6.png)\n\n   **OutputStream**    类常用方法  \n\nvoid write(int c)\n\nvoid write(byte[] buf)\n\nvoid write(byte[] b,int off,int len)\n\nvoid close()\n\nvoid flush()：强制把缓冲区的数据写到输出流中\n\n   **子类    FileOutputStream**    常用的构造方法  \n\nFileOutputStream (File file)\n\nFileOutputStream(String name) \n\nFileOutputStream(String name,boolean append)\n\n  1    .    前    两种构造方法在向文件写数据时将覆盖文件中原有的内容  \n\n  2    .    创建    FileOutputStream    实例时，如果相应的文件并不存在，则会自动创建一个空的文件  \n\n  **使用FileOutputStream 写文本文件**  \n\n![7](../images/java进阶-学习笔记(二)/7.png)\n\n  **Reader类**  \n\n   Reader    类常用方法  \n\nint read( )\n\nint read(char[] c)\n\nread(char[] c,int off,int len)\n\nvoid close( )\n\n   **子类**    **InputStream    Reader**    常用的构造方法  \n\nInputStreamReader(InputStream in)\n\nInputStreamReader(InputStream in,String charsetName)\n\n  **FileReader类**  \n\n   FileReader    类是    InputStream    Reader    的子类  \n\nFileReader(File file)\n\nFileReader(String name)\n\n   该类只能按照本地平台的字符编码来读取数据，用户不能指定其他的字符编码类型  \n\nSystem.out.println(System.getProperty(\"file.encoding\")); 获得本地平台的字符编码类型\n\n  **使用FileReader读取文件**  \n\n   与字节流    FileInputStream    类实现文本文件读取步骤类似  \n\n   如何提高字符流读取文本文件的效率？  \n\n **使用FileReader类与BufferedReader类**\n\n  BufferedReader    类是    Reader    类的子类  \n\n  BufferedReader    类带有缓冲区  \n\n  按行读取内容的    readLine()    方法  \n\n   BufferedReader    常用的构造方法  \n\nBufferedReader(Reader in)\n\n   子类    BufferedReader    特有的方法  \n\n  readLine()\n\n  **使用 BufferedReader读文本文件**  \n\n![8](../images/java进阶-学习笔记(二)/8.png)\n\n  **Writer类**  \n\n   Writer    类常用方法  \n\nwrite(String str)\n\nwrite(String str,int off,int len)\n\nvoid close()\n\nvoid flush()\n\n   **子类    OutputStream    Writer**    常用的构造方法  \n\nOutputStreamWriter(OutputStream out)\n\nOutputStreamWriter(OutputStream out,String charsetName)\n\n  **FileWriter类**  \n\n   FileWriter    类是    OutputStream    Writer    的子类  \n\nFileWriter (File file)\n\nFileWriter (String name)\n\n   该类只能按照本地平台的字符编码来写数据，用户不能指定其他的字符编码类型  \n\n  **使用FileWriter写文件**  \n\n   与字节流    FileOutputStream    类实现向文本文件写入数据步骤类似  \n\n   如何提高字符流写文本文件的效率？  \n\n 使用FileWriter类与BufferedWriter类\n\n  BufferedWriter    类是    Writer    类的子类  \n\n  BufferedWriter    类带有缓冲区  \n\n   BufferedWriter    常用的构造方法  \n\n  BufferedWriter(Writer out)\n\n  **使用 BufferedWriter写文件**  \n\n![9](../images/java进阶-学习笔记(二)/9.png)\n\n  **读写二进制文件**  \n\n   DataInputStream    类  \n\nFileInputStream的子类\n\n 与FileInputStream类结合使用读取二进制文件\n\n   DataOutputStream    类  \n\nFileOutputStream的子类\n\n 与FileOutputStream类结合使用写二进制文件\n\n  **使用 DataInputStream 读写二进制文件**  \n\n  与字节流    FileInputStream    类实现文本文件读取步骤极其相似  \n\n  与字节流    FileOutputStream    类实现文本文件读取步骤极其相似  ","tags":["java"],"categories":["技术"]},{"title":"java进阶-学习笔记(一)","slug":"java进阶-学习笔记(一)","url":"/2022/06/01/java-jin-jie-xue-xi-bi-ji-yi/","content":"\n  **集合框架和泛型**  \n\n如果并不知道程序运行时会需要多少对象，或者需要更复杂方式存储对象——可以使用Java集合框架\n\nJava集合框架提供了一套性能优良、使用方便的接口和类，它们位于java.util包中\n\n![1](../images/java进阶-学习笔记(一)/1.png)\n\nCollection 接口存储一组不唯一，无序的对象\n\nList 接口存储一组不唯一，有序（插入顺序）的对象\n\nSet 接口存储一组唯一，无序的对象 \n\nMap接口存储一组键值对象，提供key到 value    的映射  \n\nArrayList实现了长度可变的数组，在内存中分配连续的空间，遍历元素和随机访问元素的效率比较高\n\nLinkedList采用链表存储方式，插入、删除元素时效率比较高  \n\n  **ArrayList特点**  \n\nArrayList类是List接口的一个具体实现类\n\nArrayList对象实现了可变大小的数组\n\n随机访问和遍历元素时，它提供更好的性能\n\nArrayList集合中可以添加任何类型的数据，并且添加的数据都将转换成Object类型。\n\n  **ArrayList常用方法**  \n\n```java\nboolean add(Object o)   在列表的末尾顺序添加元素，起始索引位置从0开始\nvoid add(int index,Object o)   在指定的索引位置添加元素。索引位置必须介于0和列表中元素个数之间\nint size()  返回列表中的元素个数\nObject get(int index)  返回指定索引位置处的元素。取出的元素是Object类型，使用前需要进行强制类型转换\nboolean contains(Object o)  判断列表中是否存在指定元素\nboolean remove(Object o)  从列表中删除元素\nObject remove(int index) 从列表中删除指定位置元素，起始索引位置从0开始\n\nCollection接口常用通用方法还有：clear()、isEmpty()、iterator()、toArray()\n```\n\n  **LinkedList常用方法**  \n\n除了具有ArrayList对象的所有方法外，还增加了以下方法：\n\n```java\nvoid  addFirst(Object o)  在列表的首部添加元素\nvoid  addLast(Object o)  在列表的末尾添加元素\nObject  getFirst()       返回列表中的第一个元素\nObject  getLast()        返回列表中的最后一个元素\nObject  removeFirst()    删除并返回列表中的第一个元素\nObject  removeLast()     删除并返回列表中的最后一个元素\n```\n\n  **Set接口**  \n\nSet接口存储一组唯一，无序的对象，不能保存重复对象\n\n​    HashSet是Set接口常用的实现类    \n\nSet中存放对象的引用  \n\n```java\nSet set=new HashSet();\nString s1=new String(\"java\");\nString s2=s1;\nString s3=new String(\"JAVA\");\nset.add(s1);\nset.add(s2);\nset.add(s3);\nSystem.out.println(set.size());\n```\n\n![3](../images/java进阶-学习笔记(一)/3.png)\n\n采用对象的equals()方法比较两个对象是否相等\n\n  **迭代器Iterator**  \n\n​    如何遍历Set集合呢？    \n\n  方法    1    ：通过迭代器    Iterator    实现遍历  \n\n获取Iterator ：Collection 接口的iterator()方法\n\n**Iterator的方法**\n\nboolean hasNext(): 判断是否存在另一个可访问的元素 \n\nObject next(): 返回要访问的下一个元素\n\n  方法    2    ：增强型    for    循环  \n\n  **Map接口**  \n\n存储一组成对的键-值对象，提供key到value的影视\n\nkey-value不能重复\n\nkey不要求有序，但不允许重复\n\nvalue不要求有序，但允许重复\n\n  **Map接口常用方法**  \n\n```java\nObject put(Object key, Object val)      以“键-值”对的方式进行存储\nObject get(Object key)          根据键返回相关联的值，如果不存在指定的键，返回null\nObject remove(Object key)       删除由指定的键映射的“键-值对”\nint size()                      返回元素个数\nSet keySet()                   返回键的集合\nCollection values()            返回值的集合\nboolean containsKey(Object key)    如果存在由指定的键映射的“键-值对”，返回true\n\n```\n\n  **遍历Map集合**  \n\n  方法1：通过迭代器Iterator实现遍历  \n\n  方法    2 ：增强型    for    循环  \n\n  方法    3    ：键值对  \n\n\n\n  **Collections算法类**  \n\n  Java    集合框架将针对不同数据结构算法的实现都保存在工具类中  \n\n  Collections    类定义了一系列用于操作集合的静态方法  \n\n  **Collections类常用方法**  \n\n  Collections和Collection不同，前者是集合的操作类，后者是集合接口  \n\n  Collections    提供的常用静态方法  \n\nsort():排序\n\nbinarySearch()：查找\n\nmax()\\min():查找最大\\最小值\n\nfill():将List集合中的所有元素替换为相同的元素\n\n  Collections排序  \n\n  Collections    类可以对集合进行排序、查找和替换操作  \n\n  实现一个类的对象之间比较大小，该类要实现    Comparable    接口  \n\n重写compareTo()方法\n\n  **泛型集合**  \n\n  如何解决以下强制类型转换时容易出现的异常问题  \n\nList的get(int index)方法获取元素\n\nMap的get(Object key)方法获取元素\n\nIterator的next()方法获取元素\n\n  通过泛型  \n\nJDK5.0使用泛型改写了集合框架中的所有接口和类\n\n\n\n  **泛型**  \n\n  将对象的类型作为参数，指定到其他类或者方法上，从而保证类型转换的安全性和稳定性  \n\n本质是参数化类型\n\n  阅读如下代码，思考运行  \n\n```java\n//创建学员集合\nArrayList<Student> students = new ArrayList<Student>();\n//创建学员类对象\nStudent student = new Student();\n//创建诗类对象\nPoem poem = new Poem();\n//将两个对象添加到list集合中\nstudents.add(student);  由于创建时已指定Student类型，所以这里会报错\nstudents.add(poem);\n\n```\n\n  泛型集合可以约束集合内的元素类型  \n\n  典型泛型集合    ArrayList    <E>    、    HashMap    <K,V>  \n\n<E>、<K,V>表示该泛型集合中的元素类型\n\n泛型集合中的数据不再转换为Object\n\n  Java    引入泛型的好处是安全简单，且所有强制转换都是自动和隐式进行的  \n\n  **深入泛型    ——    泛型类**  \n\n  将泛型的本质是参数化    类型，参数化类型的重要性在于允许创建一些类、接口和方法，其所操作的数据类型被定义为参数，可以在真正使用时指定具体的类型。  \n\n  **两个概念：**  \n\n参数化类型：参数化类型包含一个类或接口，以及实际的类型参数列表\n\n类型变量：是一种非限定性标识符，用来指定类、接口或者方法的类型","tags":["java"],"categories":["技术"]},{"title":"python3入门机器学习","slug":"python3机器学习","url":"/2022/05/19/python3-ji-qi-xue-xi/","content":"\n python3入门机器学习_经典算法与应用\n\n经典课程，想入门机器学习的不可错过\n\n链接：https://pan.baidu.com/s/1ReUgyFv6K2CxWLDuQ9HOCw \n提取码：uthd ","tags":["机器学习","python"],"categories":["资源"]},{"title":"MySQL经典50题","slug":"MySQL经典练习50题","url":"/2022/05/12/mysql-jing-dian-lian-xi-50-ti/","content":"\n\n\n![](../images/MySQL经典练习50题/image-20220512184641309.png)\n\n![](../images/MySQL经典练习50题/image-20220512184702510.png)\n\n链接：https://pan.baidu.com/s/1gBb-icHTf1ocgd-RtMvTRg \n提取码：mb55 ","tags":["sql"],"categories":["资源"]},{"title":"vue学习笔记(三)","slug":"vue学习笔记(三)","url":"/2022/05/11/vue-xue-xi-bi-ji-san/","content":"\n**路由**\n\n在 SPA 项目中，不同功能之间的切换，要依赖于前端路由来完成\n\n前端路由，指的是 Hash 地址与组件之间的对应关系\n\n**vue-router**\n\n在 vue3 的项目中，只能安装并使用 vue-router 4.x\n\n```\nnpm install vue-router@next -s\n```\n\n在项目中定义 MyHome.vue、MyMovie.vue、MyAbout.vue 三个组件，将来要使用 vue-router 来控制它们 的展示与切换：![](../images/vue学习笔记(三)/1.png)\n\n可以使用 <router-link> 标签来声明路由链接，并使用 <router-view> 标签来声明路由占位符\n\n```html\n<template>\n  <div>\n    <h1>vue-router 的基本使用</h1>\n    <!-- 声明路由链接 -->\n    <router-link to=\"/home\">首页</router-link>&nbsp;\n    <router-link to=\"/movie\">电影</router-link>&nbsp;\n    <router-link to=\"/about\">关于</router-link>\n    <hr />\n\n    <!-- 路由的占位符 -->\n    <router-view></router-view>\n  </div>\n</template>\n```\n\n在项目中创建 router.js 路由模块，在其中按照如下 4 个步骤创建并得到路由的实例对象：  \n\n```javascript\n//① 从 vue-router 中按需导入两个方法\nimport { createRouter, createWebHashHistory } from 'vue-router'\n//② 导入需要使用路由控制的组件 \nimport Home from './MyHome.vue'\nimport Movie from './MyMovie.vue'\nimport About from './MyAbout.vue'\n//  ③ 创建路由实例对象\nconst router = createRouter({\n  // 指定路由的工作模式\n  history: createWebHashHistory(),\n  // 自定义路由高亮的 class 类\n  linkActiveClass: 'active-router',\n  // 声明路由的匹配规则\n  routes: [\n    { path: '/', redirect: '/home' },\n    { path: '/home', component: Home },\n    { path: '/movie', component: Movie },\n    { path: '/about', component: About },\n  ],\n})\n// ④ 向外共享路由实例对象\nexport default router\n\n```\n\n```javascript\n//⑤ 在 main.js 中导入并挂载路由模块\nimport { createApp } from 'vue'\nimport App from './App.vue'\nimport './index.css'\n//导入路由模块\nconst app = createApp(App)\n// 挂载路由模块\napp.use(router)\n\napp.mount('#app')\n```\n\n**vue-router 的高级用法**\n\n*路由重定向*\n\n路由重定向指的是：用户在访问地址 A 的时候，强制用户跳转到地址 C ，从而展示特定的组件页面。 通过路由规则的 redirect 属性，指定一个新的路由地址，可以很方便地设置路由的重定向\n\n```javascript\nimport { createRouter, createWebHashHistory } from 'vue-router'\n\nimport Home from './MyHome.vue'\nimport Movie from './MyMovie.vue'\nimport About from './MyAbout.vue'\n\nimport Tab1 from './tabs/MyTab1.vue'\nimport Tab2 from './tabs/MyTab2.vue'\n\n// 创建路由对象\nconst router = createRouter({\n  // 指定路由的工作模式\n  history: createWebHashHistory(),\n  // 自定义路由高亮的 class 类\n  linkActiveClass: 'active-router',\n  // 声明路由的匹配规则\n  routes: [\n    { path: '/', redirect: '/home' },//path指向原地址，redirect指向新地址\n    { path: '/home', component: Home },\n    { path: '/movie', component: Movie },\n    {\n      path: '/about',\n      component: About,\n      // 嵌套路由的重定向\n      redirect: '/about/tab1',\n      // 通过 children 属性嵌套声明子级路由规则\n      children: [\n        { path: 'tab1', component: Tab1 },\n        { path: 'tab2', component: Tab2 },\n      ],\n    },\n  ],\n})\n// 导出路由对象\nexport default router\n```\n\n在 About.vue 组件中，声明 tab1 和 tab2 的子路由链接以及子路由占位符\n\n```html\n<template>\n  <div>\n    <h3>MyAbout 组件</h3>\n    <!-- 声明子路由链接 -->\n    <router-link to=\"/about/tab1\">Tab1</router-link>&nbsp;\n    <router-link to=\"/about/tab2\">Tab2</router-link>\n    <hr>\n    <!-- 声明子路由占位符 -->\n    <router-view></router-view>\n  </div>\n</template>\n```\n\n*动态路由匹配*\n\n动态路由指的是：把 Hash 地址中可变的部分定义为参数项，从而提高路由规则的复用性。在 vue-router 中 使用英文的冒号（:）来定义路由的参数项\n\n```javascript\n{path: '/movie/:id', component:Movie}\n```\n\n```html\n<router-link to=\"/movie/1\">电影1</router-link>\n<router-link to=\"/movie/2\">电影2</router-link>\n<router-link to=\"/movie/3\">电影3</router-link>\n```\n\n通过动态路由匹配的方式渲染出来的组件中，可以使用 $route.params 对象访问到动态匹配的参数值\n\n```html\n//1、定义路由规则时声明props：true选项\n{path: '/movie/:id', component:Movie, props:true}\n<template>\n  //直接使用props中接受的路由参数\n    <h3>MyMovie 组件 --- {{ id }}</h3>\n</template>\n\n<script>\nexport default {\n  props:['id']  //2、使用props接收路由规则匹配到的参数项\n}\n</script>\n```\n\n为了简化路由参数的获取形式，vue-router 允许在路由规则中开启 props 传参\n\n```html\n<template>\n    <h3>MyMovie 组件 --- {{ $route.params.id }}</h3>\n</template>\n\n<script>\nexport default {\n  name: 'MyMovie',\n}\n</script>\n```\n\n*编程式导航*\n\n通过调用 API 实现导航的方式，叫做编程式导航。与之对应的，通过点击链接实现导航的方式，叫做声明式导航。\n\nvue-router 中的编程式导航 API\n\n① this.$router.push('hash 地址')              跳转到指定 Hash 地址，从而展示对应的组件\n\n ② this.$router.go(数值 n)                         实现导航历史的前进、后退\n\n```html\n<template>\n  <div>\n    <h3>MyMovie 组件 --- {{ $route.params.mid }} --- {{ mid }}</h3>\n    <button type=\"button\" class=\"btn btn-danger\" @click=\"goBack\">后退</button>\n    <button @click='gotoMovie(3)'>go to movie</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'MyMovie',\n  props: ['mid'],\n  methods: {\n    goBack() {\n      this.$router.go(-1)\n    },\n    gotoMovie(id){\n      this.$router.push('/movie/${id}')\n    }\n  },\n}\n</script>\n\n```\n\n*命名路由*\n\n通过 name 属性为路由规则定义名称的方式，叫做命名路由\n\n```javascript\n{\npath: '/movie:id',\nname: 'mov',\ncomponent: Movie,\nprops: true\n}\n```\n\n命名路由的 name 值不能重复，必须保证唯一性\n\n```html\n<!--为 <router-link> 标签动态绑定 to 属性的值，并通过 name 属性指定要跳转到的路由规则。期间还可以用params 属性指定跳转期间要携带的路由参数。-->\n\n<!--调用 push 函数期间指定一个配置对象，name 是要跳转到的路由规则、params 是携带的路由参数 -->\n<template>\n  <div>\n    <h3>MyHome 组件</h3>\n    <router-link :to=\"{ name: 'mov', params: { mid: 2 } }\">go to movie</router-link>\n    <button type=\"button\" class=\"btn btn-primary\" @click=\"goToMovie(1)\">go to movie</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'MyHome',\n  methods: {\n    goToMovie(id) {\n      this.$router.push({\n        name: 'mov',\n        params: {\n          mid: id,\n        },\n      })\n    },\n  },\n}\n</script>\n```\n\n*导航守卫*\n\n导航守卫可以控制路由的访问权限\n\n![](../images/vue学习笔记(三)/3.png)\n\n全局导航守卫会拦截每个路由规则，从而对每个路由进行访问权限的控制。可以按照如下的方式定义全局导航 守卫：\n\n```javascript\nconst router = createRouter({...})\n//fn是一个函数，每次拦截到路由请求，都会调用，因此被称为守卫方法\nrouter.beforeEach(fn)\n```\n\n全局导航守卫的守卫方法中接收 3 个形参\n\n```javascript\nconst router = createRouter({...})\n\nrouter.beforeEach((to,from,next)=>{\n//to是目标路由对象\n  //from当前导航正要离开的路由对象\n  //next是一个函数，表示放行\n})\n```\n\n在守卫方法中如果不声明 next 形参，则默认允许用户访问每一个路由！\n\n在守卫方法中如果声明了 next 形参，则必须调用 next() 函数，否则不允许用户访问任何一个路由！\n\n*next 函数*\n\n直接放行：next()            强制其停留在当前页面：next(false)            强制其跳转到登录页面：next('/login')\n\n结合 token 控制后台主页的访问权限\n\n```javascript\n// 全局路由导航守卫\nrouter.beforeEach((to, from, next) => {\nconst tokenStr = localStorage.getItem('token')\n\n  if (to.path === '/main' && !tokenStr) {\n    // 证明用户要访问后台主页\n    next('/login')\n  } else {\n    // 访问的不是后台主页\n    next()\n  }\n})\n```\n\n**vue-cli**\n\nvue-cli（俗称：vue 脚手架）是 vue 官方提供的、快速生成 vue 工程化项目的工具。\n\n```\nnpm install -g @vue/cli\nvue --version\n```\n\n创建项目\n\n```\nvue create xxx\n//or\nvue ui\n```\n\nmain.js 中的主要代码\n\n```javascript\n//1、导入vue的构造函数\nimport Vue from 'vue'\n//2、导入App根组件\nimport App from './App.vue'\n//屏蔽浏览器console提示消息\nVue.config.productionTip = false\n//3、创建vue实例对象\nnew Vue({\n  render: h => h(App),\n}).$mount('#app')\n```\n\n**组件库**\n\nPC 端 \n\n Element UI（https://element.eleme.cn/#/zh-CN） \n\n View UI（http://v1.iviewui.com/） \n\n移动端 \n\nMint UI（http://mint-ui.github.io/#!/zh-cn） \n\nVant（https://vant-contrib.gitee.io/vant/#/zh-CN/）\n\n```javascript\n//在main.js中写入\n//完整引入\nimport ElementUI from 'element-ui'\n//注册为vue组件\nVue.use(ElementUI)\n```\n\na**xios 拦截器**\n\n```javascript\nimport Vue from 'vue'\nimport App from './App.vue'\nimport router from './router/index.js'\n// 导入并注册 element-ui 组件\nimport './element-ui'\nimport { Loading } from 'element-ui'\n\nimport axios from 'axios'\n// 配置请求根路径\n// axios.defaults.baseURL = 'https://www.escook.cn'\naxios.defaults.baseURL = 'http://localhost:8080'\n// 配置请求拦截器\nlet loadingInstance = null\naxios.interceptors.request.use(config => {\n  // 展示 loading 效果\n  loadingInstance = Loading.service({ fullscreen: true })\n  // 配置 Token 认证\n  config.headers.Authorization = 'Bearer xxx'\n  console.log(config)\n  // 这是固定写法\n  return config\n})\n// 配置响应拦截器\naxios.interceptors.response.use(response => {\n  // 关闭 loading 效果\n  loadingInstance.close()\n  return response\n})\nVue.prototype.$http = axios\n\nconst app = new Vue({\n  render: h => h(App),\n  // router: router\n  router,\n})\n\napp.$mount('#app')\n\n```\n\n**proxy 跨域代理**\n\n通过 vue-cli 创建的项目在遇到接口跨域问题时，可以通过代理的方式来解决：\n\n① 把 axios 的请求根路径设置为 vue 项目的运行地址（接口请求不再跨域） ② vue 项目发现请求的接口不存在，把请求转交给 proxy 代理 ③ 代理把请求根路径替换为 devServer.proxy 属性的值，发起真正的数据请求 ④ 代理把请求到的数据，转发给 axios\n\n步骤1，在 main.js 入口文件中，把 axios 的请求根路径改造为当前 web 项目的根路径：\n\n```javascript\naxios.defaults.baseURL = 'http://localhost:8080'\n```\n\n步骤2，在项目根目录下创建 vue.config.js 的配置文件，并声明如下的配置：\n\n```javascript\nmodule.exports = {\n  devServer: {\n    proxy: 'https://www.escook.cn',\n  },\n}\n```\n\n注意： ① devServer.proxy 提供的代理功能，仅在开发调试阶段生效 ② 项目上线发布时，依旧需要 API 接口服务器开启 CORS 跨域资源共享\n","tags":["vue","前端"],"categories":["技术"]},{"title":"vue学习笔记(二)","slug":"vue学习笔记(二)","url":"/2022/05/10/vue-xue-xi-bi-ji-er/","content":"\n**watch 侦听器**\n\nwatch 侦听器允许开发者监视数据的变化，从而针对数据的变化做特定的操作。\n\n```html\n<template>\n  <div>\n    <h3>watch 侦听器的用法</h3>\n    <input type=\"text\" class=\"form-control\" v-model.trim=\"info.username\" />\n  </div>\n</template>\n\n<script>\nimport axios from 'axios'\n\nexport default {\n  name: 'MyWatch',\n  data() {\n    return {\n      username: 'admin',\n      info: {\n        username: 'zs',\n        age: 20,\n      },\n    }\n  },\n  watch: {\n      //1、监听usernname变化值，形参列表中第一个是“变化后的新值”，第二个是变化前的“旧值”\n     username: {\n       //2、handler属性是固定写法，当username变化时，调用handler\n       async handler(newVal, oldVal) {\n         const { data: res } = await axios.get('https://www.escook.cn/api/finduser/' + newVal)\n         console.log(res)\n       },\n       //3、组件在初次加载完毕后不会调用 watch 侦听器。如果想让 watch 侦听器立即被调用，则需要使用 immediate 选项\n       immediate: true,\n     },\n      \n     info: {//监听info对象变化\n       async handler(newVal) {\n         const { data: res } = await axios.get('https://www.escook.cn/api/finduser/' + newVal.username)\n         console.log(res)\n       },\n       deep: true,//当 watch 侦听的是一个对象，如果对象中的属性值发生了变化，则无法被监听到。此时需要使用 deep 选项\n     },\n      \n      //如果只想监听对象中单个属性的变化，则可以按照如下的方式定义 watch 侦听器\n    'info.username': {\n      async handler(newVal) {\n        const { data: res } = await axios.get('https://www.escook.cn/api/finduser/' + newVal)\n        console.log(res)\n      },\n    },\n  },\n}\n</script>\n\n<style lang=\"less\" scoped></style>\n\n```\n\n*计算属性 vs 侦听器*\n\n计算属性和侦听器侧重的应用场景不同：\n\n计算属性侧重于监听多个值的变化，最终计算并返回一个新值\n\n侦听器侧重于监听单个数据的变化，最终执行特定的业务处理，不需要有任何返回值\n\n**组件的生命周期**\n\n组件的生命周期指的是：组件从创建 -> 运行（渲染） -> 销毁的整个过程，强调的是一个时间段。\n\nvue 框架为组件内置了不同时刻的生命周期函数，生命周期函数会伴随着组件的运行而自动调用。例如：\n\n① 当组件在内存中被创建完毕之后，会自动调用 created 函数\n\n② 当组件被成功的渲染到页面上之后，会自动调用 mounted 函数\n\n③ 当组件被销毁完毕之后，会自动调用 unmounted 函数\n\n当组件的 data 数据更新之后，vue 会自动重新渲染组件的 DOM 结构，从而保证 View 视图展示的数据和\n\nModel 数据源保持一致。\n\n当组件被重新渲染完毕之后，会自动调用 updated 生命周期函数。\n\n![2](../images/vue学习笔记(二)/2.png)\n\n| 生命周期函数 | 执行时机                     | 所属阶段 | 执行次数  | 应用场景             |\n| ------------ | ---------------------------- | -------- | --------- | -------------------- |\n| created      | 组件在内存中创建完毕后       | 创建阶段 | 唯一1次   | 发 ajax 请求初始数据 |\n| mounted      | 组件初次在页面中渲染完毕后   | 创建阶段 | 唯一1次   | 操作 DOM 元素        |\n| updated      | 组件在页面中被重新渲染完毕后 | 运行阶段 | 0 或 多次 | -                    |\n| unmounted    | 组件被销毁后（页面和内存）   | 销毁阶段 | 唯一1次   | -                    |\n\n可以参考 vue 官方文档给出的“生命周期图示”，进一步理解组件生命周期执行的过程：\nhttps://www.vue3js.cn/docs/zh/guide/instance.html#生命周期图示  \n\n**组件之间的数据共享**  \n\n*父组件向子组件共享数据*\n父组件通过 v-bind 属性绑定向子组件共享数据。同时，子组件需要使用 props 接收数据  \n\n子组件通过自定义事件的方式向父组件共享数据。  \n\n```html\n<template>\n  <div>\n    <h1>App 根组件 -- {{ count }}</h1>\n    <button type=\"button\" class=\"btn btn-primary\" @click=\"count += 1\">+1</button>\n    <hr />\n\n    <!-- 3. 以标签形式使用子组件 -->\n    <!-- <my-son :num=\"count\" @numchange=\"getNum\"></my-son> -->\n    <my-son v-model:num=\"count\"></my-son>\n  </div>\n</template>\n\n<script>\n// 1. 导入子组件\nimport MySon from './Son.vue'\n\nexport default {\n  name: 'MyApp',\n  data() {\n    return {\n      count: 0,\n    }\n  },\n  // methods: {\n  //   getNum(num) {\n  //     this.count = num\n  //   }\n  // },\n  // 2. 注册子组件\n  components: {\n    MySon,\n  },\n}\n</script>\n\n<style lang=\"less\" scoped></style>\n\n```\n\n```html\n<template>\n  <div>\n    <h3>Son 子组件 --- {{ num }}</h3>\n    <button type=\"button\" class=\"btn btn-danger\" @click=\"add\">+1</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'MySon',\n  props: ['num'],\n  emits: ['update:num'],\n  // emits: ['numchange'],\n  methods: {\n    add() {\n      // this.$emit('numchange', this.num + 1)\n      this.$emit('update:num', this.num + 1)\n    },\n  },\n}\n</script>\n\n<style lang=\"less\" scoped></style>\n\n```\n\n父组件在使用子组件期间，可以使用 v-model 指令维护组件内外数据的双向同步  \n\n*兄弟组件之间的数据共享*\n兄弟组件之间实现数据共享的方案是 EventBus。可以借助于第三方的包 mitt 来创建 eventBus 对象，从而实现兄弟组件之间的数据共享。\n\n  ![1](../images/vue学习笔记(二)/1.png)\n\n安装 mitt 依赖包：  \n\n```cmd\nnpm install mitt@2.1.0\n```\n\n在项目中创建公共的 eventBus 模块  \n\n```\nimport mitt from 'mitt'\nconst bus = mitt()\nexport default bus\n```\n\n在数据接收方，调用 bus.on('事件名称', 事件处理函数) 方法注册一个自定义事件。  \n\n```html\n<script>\nimport bus from './eventBus.js'\n\nexport default {\n  name: 'MyRight',\n  data() {\n    return {\n      num: 0,\n    }\n  },\n  created() {\n    bus.on('countChange', count => {\n      this.num = count\n    })\n  },\n}\n</script>\n```\n\n在数据发送方，调用 bus.emit('事件名称', 要发送的数据) 方法触发自定义事件  \n\n```html\n<script>\nimport bus from './eventBus.js'\n\nexport default {\n  name: 'MyLeft',\n  data() {\n    return {\n      count: 0,\n    }\n  },\n  methods: {\n    add() {\n      this.count++\n      bus.emit('countChange', this.count)\n    },\n  },\n}\n</script>\n```\n\n*后代关系组件之间的数据共享*\n后代关系组件之间共享数据，指的是父节点的组件向其子孙组件共享数据。此时组件之间的嵌套关系比较复杂，可以使用 provide 和 inject 实现后代关系组件之间的数据共享。  \n\n父节点的组件可以通过 provide 方法，对其子孙组件共享数据：  \n\n```html\n<script>\nexport default {\n  name: 'MyApp',\n  data() {\n    return {\n      color: 'red',\n    }\n  },\n  provide() {\n    // 返回要共享的数据对象\n    return {\n      color: computed(() => this.color),//可以结合 computed 函数向下共享响应式的数据\n      count: 1,\n    }\n  },\n  components: {\n    LevelTwo,\n  },\n}\n</script>\n```\n\n子孙节点可以使用 inject 数组，接收父级节点向下共享的数据  \n\n```html\n<template>\n  <div>\n      //如果父级节点共享的是响应式的数据，则子孙节点必须以 .value 的形式进行使用\n    <h5>Level Three 三级组件 --- {{ color.value }} --- {{ count }}</h5>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'LevelThree',\n  inject: ['color', 'count'],\n}\n</script>\n```\n\n*vuex*\nvuex 是终极的组件之间的数据共享方案。在企业级的 vue 项目开发中，vuex 可以让组件之间的数据共享变得高\n效、清晰、且易于维护  \n\n**vue 3.x 中全局配置 axios**  \n\n在 main.js 入口文件中，通过 app.config.globalProperties 全局挂载 axios  \n\n![img](../images/vue学习笔记(二)/3.png)\n\n**ref 引用** \n\n ref 用来辅助开发者在不依赖于 jQuery 的情况下，获取 DOM 元素或组件的引用。\n每个 vue 的组件实例上，都包含一个 $refs 对象，里面存储着对应的 DOM 元素或组件的引用。默认情况下，\n组件的 $refs 指向一个空对象。  \n\n```html\n<template>\n  <div>\n    <h1 ref=\"myh11\">App 根组件</h1>\n    <hr />\n\n    <button type=\"button\" class=\"btn btn-primary\" @click=\"getRefs\">获取 $refs 引用</button>\n\n    <my-counter ref=\"counterRef\"></my-counter>\n  </div>\n</template>\n\n<script>\n// 导入组件\nimport MyCounter from './Counter.vue'\n\nexport default {\n  name: 'MyApp',\n  methods: {\n    getRefs() {\n       console.log(this.$refs)\n       this.$refs.myh11.style.color = 'red'  //通过this.$refs.xxx,可以获得DOM元素引用\n\n       console.log(this.$refs.counterRef)\n        //使用 ref 引用页面上的组件实例\n      this.$refs.counterRef.reset()\n    },\n  },\n  // 注册组件\n  components: {\n    MyCounter,\n  },\n}\n</script>\n```\n\n```html\n<script>\nexport default {\n  name: 'MyApp',\n  data() {\n    return {\n      inputVisible: false,\n    }\n  },\n  methods: {\n    showInput() {\n      // 要展示文本框\n      this.inputVisible = true\n        //组件的 $nextTick(cb) 方法，会把 cb 回调推迟到下一个 DOM 更新周期之后执行。\n      this.$nextTick(() => {\n        console.log(this.$refs.ipt)\n        // 获取到文本框的引用对象，然后调用 focus() 方法\n        this.$refs.ipt.focus()\n      })\n    },\n  },\n}\n</script>\n```\n\n**动态组件**  \n\n动态组件指的是动态切换组件的显示与隐藏。vue 提供了一个内置的 <component> 组件，专门用来实现组件的动态渲染。  \n\n```\n①  <component> 是组件的占位符\n② 通过 is 属性动态指定要渲染的组件名称\n③ <component is=\"要渲染的组件的名称\"></component> \n```\n\n \n\n```HTML\n<template>\n  <div>\n    <h1 class=\"mb-4\">App 根组件</h1> //3、点击按钮，动态切换组件名称\n    <button type=\"button\" class=\"btn btn-primary\" @click=\"comName = 'MyHome'\">首页</button>\n    <button type=\"button\" class=\"btn btn-info ml-2\" @click=\"comName = 'MyMovie'\">电影</button>\n    <hr />\n    <!-- 使用组件 -->\n    <!-- <my-home></my-home>\n    <my-movie></my-movie> -->\n    <keep-alive>             // <keep-alive> 组件保持动态组件的状态\n      <component :is=\"comName\"></component>  //2、通过is属性，动态指定要渲染的组件名称\n    </keep-alive>\n  </div>\n</template>\n....\ndata() {\n    return {\n      comName: 'MyHome'        //1、当前要渲染的组件名称\n    }\n  },\n```\n\n**插槽**  \n\n插槽（Slot）是 vue 为组件的封装者提供的能力。允许开发者在封装组件时，把不确定的、希望由用户指定的部分定义为插槽。  可以把插槽认为是组件封装期间，为用户预留的内容的占位符。  \n\n![image-20220511152126248](../images/vue学习笔记(二)/image-20220511152126248.png)\n\n```html\n<template>\n  <div class=\"com-container\">\n    <h3>MyCom 组件 --- 插槽的基础用法</h3>\n    <hr />\n\n    <p>这是第一个 p 标签</p>\n    <slot>这是后备内容</slot>\n    <p>这是最后一个 p 标签</p>\n  </div>\n</template>\n```\n\n在封装组件时，可以通过 <slot> 元素定义插槽，从而为用户预留内容占位符。  \n\n如果在封装组件时没有预留任何 <slot> 插槽，则用户提供的任何自定义内容都会被丢弃。  \n\n封装组件时，可以为预留的 <slot> 插槽提供后备内容（默认内容）。如果组件的使用者没有为插槽提供任何内容，则后备内容会生效。  \n\n```html\n如果在封装组件时需要预留多个插槽节点，则需要为每个 <slot> 插槽指定具体的 name 名称。这种带有具体名称的插槽叫做“具名插槽”。  \n<template>\n  <div>\n    <!-- 我们希望把页头放到这里 -->\n    <header>\n      <slot name=\"header\"></slot>\n    </header>\n    <!-- 我们希望把主要内容放到这里 -->\n    <main>\n      <slot></slot>\n    </main>\n    <!-- 我们希望把页脚放到这里 -->\n    <footer>\n      <slot name=\"footer\"></slot>\n    </footer>\n  </div>\n</template>\n```\n\n```html\n在向具名插槽提供内容的时候，我们可以在一个 <template> 元素上使用 v-slot 指令，并以 v-slot 的参数的形式提供其名称。\n 跟 v-on 和 v-bind 一样，v-slot 也有缩写，即把参数之前的所有内容 (v-slot:) 替换为字符 #。例如 v-slot:header可以被重写为 #header\n<template>\n  <div>\n    <h1>App 根组件</h1>\n    <hr />\n\n    <!-- 使用组件 -->\n    <my-article>\n      <template #header>\n        <h1>滕王阁序</h1>\n      </template>\n      <template #default>\n        <p>豫章故郡，洪都新府。</p>\n        <p>星分翼轸，地接衡庐</p>\n        <p>襟三江而带五湖，控蛮荆而引瓯越。</p>\n      </template>\n      <template #footer>\n        <p>落款：王勃</p>\n      </template>\n    </my-article>\n  </div>\n</template>\n```\n\n*作用域插槽*  \n\n在封装组件的过程中，可以为预留的 <slot> 插槽绑定 props 数据，这种带有 props 数据的 <slot> 叫做“作用域插槽”。  \n\n```html\n<template>\n  <div>\n    <h3>这是 TEST 组件</h3>\n    <slot :info=\"infomation\" :msg=\"message\"></slot>\n  </div>\n</template>\n\n <!-- 使用自定义组件 -->\n    <my-test>\n      <template #default=\"{ msg, info }\">\n        <p>{{ msg }}</p>\n        <p>{{ info.address }}</p>\n      </template>\n    </my-test>\n```\n\n作用域插槽对外提供的数据对象，可以使用解构赋值简化数据的接收过程。  \n\n```html\n<my-table>\n      <template #default=\"{ user }\">\n        <td>{{ user.id }}</td>\n        <td>{{ user.name }}</td>\n        <td>\n          <input type=\"checkbox\" :checked=\"user.state\" />\n        </td>\n      </template>\n    </my-table>\n```\n\n在封装 MyTable 组件的过程中，可以通过作用域插槽把表格每一行的数据传递给组件的使用者。  \n\n```html\n<tbody>\n      <!-- 循环渲染表格数据 -->\n      <tr v-for=\"item in list\" :key=\"item.id\">\n        <slot :user=\"item\"></slot>\n      </tr>\n    </tbody>\n```\n\n在使用 MyTable 组件时，自定义单元格的渲染方式，并接收作用域插槽对外提供的数据。  \n\n```html\n<my-table>\n      <template v-slot:default=\"scope\">\n        <td>{{ scope.user.id }}</td>\n        <td>{{ scope.user.name }}</td>\n      </template>\n    </my-table>\n```\n\n*自定义指令*  \n\n在每个 vue 组件中，可以在 directives 节点下声明私有自定义指令。  \n\n```javascript\ndirectives: {\n//定义一个私有指令\n    focus: {\n        //当被绑定的元素插入到DOM时，自动触发mounted函数\n       mounted(el) {\n         el.focus()  //让被绑定的元素自动获得焦点\n       }\n     }\n  }\n```\n\n在使用自定义指令时，需要加上 v- 前缀。  \n\n```\n<input v-foucs />\n```\n\n全局共享的自定义指令需要通过“单页面应用程序的实例对象”进行声明  \n\nmounted 函数只在元素第一次插入 DOM 时被调用，当 DOM 更新时 mounted 函数不会被触发。 updated函数会在每次 DOM 更新完成后被调用。  \n\n```javascript\nconst app = Vue.createApp({})\napp.directive('focus',{\n\tmounted(el) {\n         el.focus()  \n      }\n    updated(el) {\n         el.focus()  \n      }\n})\n```\n\n如果 mounted 和updated 函数中的逻辑完全相同，则可以简写成如下格式  \n\n```javascript\napp.directive('focus', (el)=>{\n\tel.focus()\n})\n```\n\n在绑定指令时，可以通过“等号”的形式为指令绑定具体的参数值  \n","tags":["vue","前端"],"categories":["技术"]},{"title":"补档说明","slug":"补档说明","url":"/2022/05/09/bu-dang-shuo-ming/","content":"\n本站终于上线，我会陆续上传之前及以后的学习到的知识技能总结，包括相关笔记，也是为了记录进度，以此鞭策自己，当然也会分享一些生活日常或思想交流及转载优秀但小众的文章，尽情期待。","categories":["说明"]},{"title":"vue学习笔记(一)","slug":"vue学习笔记(一)","url":"/2022/05/09/vue-xue-xi-bi-ji-yi/","content":"\n本笔记基于bilibili黑马程序员公开课制作而成，欢迎纠错\n\nhttps://www.bilibili.com/video/BV1zq4y1p7ga?from=search&seid=8735997202777164020&spm_id_from=333.337.0.0\n\n**vue 简介**\n\nVue 是一套用于构建用户界面的<u>前端框架</u>。\n\n使用 vue 构建用户界面，解决了 jQuery + 模板引擎 的诸多痛点，极大的提高了前端开发的效率和体验。\n\nvue 全家桶：vue（核心库） vue-router（路由方案） vuex（状态管理方案） vue 组件库（快速搭建页面 UI 效果的方案）\n\nvue 框架的特性，主要体现在如下两方面：① 数据驱动视图    ② 双向数据绑定\n\nMVVM 是 vue 实现数据驱动视图和双向数据绑定的核心原理。它把每个 HTML 页面都拆分成了如下三个部分：\n\n​\t在 MVVM 概念中：\n\n![](../images/vue学习笔记(一)/1.png)\n\n​\t\tView 表示当前页面所渲染的 DOM 结构。\n\n​\t\tModel 表示当前页面渲染时所依赖的数据源。\n\n​\t\tViewModel 表示 vue 的实例，它是 MVVM 的核心。\n\n![](../images/vue学习笔记(一)/2.png)\n\n​\t工作原理：\n\n​\t\tViewModel 作为 MVVM 的核心，是它把当前页面的数据源（Model）和页面的结构（View）连接在了一起。\n\n​\t\t当数据源发生变化时，会被 ViewModel 监听到，VM 会根据最新的数据源自动更新页面的结构\n\n​\t\t当表单元素的值发生变化时，也会被 VM 监听到，VM 会把变化过后最新的值自动同步到 Model 数据源中\n\n**vue 的基本使用**\n\n① 导入 vue.js 的 script 脚本文件\n\n② 在页面中声明一个将要被 vue 所控制的 DOM 区域\n\n③ 创建 vm 实例对象（vue 实例对象）\n\n```html\n <body>\n    <!-- 2. 声明要被 vue 所控制的 DOM 区域 -->\n    <div id=\"app\">{{age}}</div>\n\n    <!-- 1. 导入 vue 的脚本文件 -->\n    <script src=\"./lib/vue-2.6.12.js\"></script>\n\n    <!-- 3. 创建 vue 的实例对象 -->\n    <script>\n      const vm = new Vue({//       -----------------------------------\n        //                                                           -\n        el: '#app',//    ------el指向的选择器，就是View试图区域        -\n        //                                                           -\n        data: {//        ------------                     new Vue()构造函数，得到的\n          username: 'zs',//   data指向的对象                   vm实例对象就是ViewModel\n          age: 20//          就是Model数据源                         -\n        },//             ------------                               -\n      })//                         -----------------------------------\n    </script>\n  </body>\n```\n\n​\tvue 官方提供的 vue-devtools 调试工具，能够方便开发者对 vue 项目进行调试与开发\n\n**vue 的指令**\n\n指令（Directives）是 vue 为开发者提供的模板语法，用于辅助开发者渲染页面的基本结构。\n\n1、内容渲染指令\n\n\n\n```\n v-text        {{ }}        v-html           内容渲染指令用来辅助开发者渲染 DOM 元素的文本内容。\n```\n\n\n\n```html\n <div id=\"app\">\n    <!-- <p v-text=\"username\"></p> \n    <p v-text=\"gender\">性别</p> -->\n\t\t\t\t\t\t\t\t\t\t\t//v-text 指令会覆盖元素内默认的值。\n    <p>姓名：{{username}}</p>\n    <p>性别：{{gender}}</p>\n\t                      //相对于 v-text 指令来说，插值表达式在开发中更常用一些！因为它不会覆盖元素中默认的文本内容。\t\n    <p>---------</p>\n\n    <p v-text=\"desc\"></p>\n    <p>{{desc}}</p>\n    <p v-html=\"desc\"></p>         //v-text 指令和插值表达式只能渲染纯文本内容。\n  </div>\n  <script>\n    const vm = new Vue({\n      el: '#app',\n      data: {\n        username: 'zs',\n        gender: '男',\n        desc: '<i style=\"color:red;\">abc<i>'\n      }\n    })\n  </script>\n```\n\n2、属性绑定指令\n\n```\nv-bind           为元素的属性动态绑定属性值\n```\n\n```html\n<input type=\"text\" v-bind:placeholder=\"inputValue\">      //简记为  :placeholder=\"inputValue\"\n<img v-bind:src=\"imgSrc\" alt=\"\">                         //        :src=\"imgSrc\"\n....\n data: {\n          // 文本框的占位符内容\n          inputValue: '请输入内容',\n          // 图片的 src 地址\n          imgSrc: './images/logo.png',\n        },\n```\n\n在 vue 提供的模板渲染语法中，除了支持绑定简单的数据值之外，还支持 Javascript 表达式的运算\n\n3、数据绑定指令\n\n```html\nv-on （简记为@）              为 DOM 元素绑定事件监听\n原生 DOM 对象有 onclick、oninput、onkeyup 等原生事件，替换为 vue 的事件绑定形式后，分别为：v-on:click、v-on:input、v-on:keyup\n```\n\n```html\n<h3>count 的值为：{{count}}</h3>\n      <!-- TODO：点击按钮，让 data 中的 count 值自增 +1 -->\n<button v-on:click=\"addCount\">+1</button>            //等价于   @click=\"addCount\"\n```\n\n通过 v-on 绑定的事件处理函数，需要在 methods 节点中进行声明\n\n```html\nmethods: {\n          // 点击按钮，让 count 自增 +1\n          addCount() {\n            this.count += 1\n          },\n```\n\n事件修饰符\n\n.prevent   阻止默认行为    .stop   阻止事件冒泡     .once   绑定的事件只触发一次\n\n```html\n<div class=\"inner\" @click.once=\"onInnerClick\">\n```\n\n按键修饰符\n\n```html\n<input type=\"text\" @keyup.enter=\"submit\" @keyup.esc=\"clearInput\" />\n```\n\n4、双向绑定指令\n\n```\nv-model      旨在不操作 DOM 的前提下，快速获取表单的数据（只能配合表单元素一起使用！）\n```\n\n```html\n<p>用户名是：{{username}}</p>\n<input type=\"text\" v-model=\"username\" />\n<select v-model=\"province\">\n        <option value=\"\">请选择</option>\n        <option value=\"1\">北京</option>\n        <option value=\"2\">河北</option>\n        <option value=\"3\">黑龙江</option>\n      </select>\n```\n\n修饰符\n\n```\n.number 自动将输入转换为数值型  .trim  自动过滤首尾留的空白字符   .lazy 在change时而不是input是更新\n```\n\n5、条件渲染指令\n\n按需控制 DOM 的显示与隐藏\n\n```\nv-if           动态地创建或移除 DOM 元素，适合于运行时条件很少改变的场景\nv-show         动态为元素添加或移除 style=\"display: none;\" 样式，适合于频繁地切换的场景\n```\n\n```html\n <p v-if=\"type === 'A'\">优秀</p>\n      <p v-else-if=\"type === 'B'\">良好</p>\n      <p v-else-if=\"type === 'C'\">一般</p>\n      <p v-else>差</p>\n```\n\n6、列表渲染指令\n\n```\nv-for           者基于一个数组来循环渲染相似的 UI 结构\n```\n\n```html\n<ul>\n      <li v-for=\"(user, index) in userlist\" :key=\"user.id\">\n        <input type=\"checkbox\" />\n        姓名：{{user.name}}\n      </li>\n</ul>\n....\ndata: {\n          // 用户列表的数据\n          list: [\n            { id: 1, name: 'zs' },\n            { id: 2, name: 'ls' },\n          ],\n        },\n```\n\n**单页面应用程序**\n\n单页面应用程序（Single Page Application）简称 SPA，指的是一个 Web 网站中只有唯一的一个 HTML 页面，所有的功能与交互都在这唯一的一个页面内完成。\n\n特点：仅在该 web 页面初始化时加载相应的资源，不会因为用户的操作而进行页面的重新加载或跳转。而是利用 JavaScript 动态地变换 HTML 的内容，从而实现页面与用户的交互。\n\n优点：良好的交互体验。良好的前后端工作分离模式。减轻服务器的压力\n\n缺点：首屏加载慢。不利于 SEO \n\n快速创建 vue 的 SPA 项目：①  vite    ②  vue-cli \n\n**vite 的基本使用**\n\n```\nnpm init vite-app 项目名称\ncd 项目名称\nnpm run install \nnpm run dev\n```\n\n梳理项目的结构\n\n使用 vite 创建的项目结构如下：\n\n![vite](../images/vue学习笔记(一)/vite-16522553466691.png)\n\nnode_modules 目录用来存放第三方依赖包                                     public 是公共的静态资源目录 \n\n src 是项目的源代码目录（程序员写的所有代码都要放在此目录下）                .gitignore 是 Git 的忽略文件 \n\nindex.html 是 SPA 单页面应用程序中唯一的 HTML 页面                   package.json 是项目的包管理配置文件\n\n在 src 这个项目源代码目录之下，包含了如下的文件和文件夹：\n\nassets 目录用来存放项目中所有的静态资源文件（css、fonts等）    components 目录用来存放项目中所有的自定义组件\n\nApp.vue 是项目的根组件             index.css 是项目的全局样式表文件                 main.js 是整个项目的打包入口文件\n\nvite 项目的运行流程\n\n在工程化的项目中，vue 要做的事情很单纯：通过 main.js 把 App.vue 渲染到 index.html 的指定区域中。\n\n其中： ① App.vue 用来编写待渲染的模板结构 ② index.html 中需要预留一个 el 区域 ③ main.js 把 App.vue 渲染到了 index.html 所预留的区域中\n\n**组件化开发思想**\n\n组件化开发指的是：根据封装的思想，把页面上可重用的部分封装为组件，从而方便项目的开发和维护。\n\n优点：提高了前端代码的复用性和灵活性，提升了开发效率和后期的可维护性\n\nvue 是一个完全支持组件化开发的框架。vue 中规定组件的后缀名是 .vue。之前接触到的 App.vue 文件本质 上就是一个 vue 的组件。\n\n**vue 组件的构成**\n\n每个 .vue 组件都由 3 部分构成，分别是：  \n\ntemplate -> 组件的模板结构                  script -> 组件的 JavaScript 行为                      style -> 组件的样式\n\n其中，每个组件中必须包含 template 模板结构，而 script 行为和 style 样式是可选的组成部分。\n\n\n```html\n<!--每个组件对应的模板结构，需要定义到 <template> 节点中。\n<template> 是 vue 提供的容器标签，只起到包裹性质的作用，它不会被渲染为真正的 DOM 元素。-->\n<template>\n  <h1>这是 <i>App.vue</i> 根组件</h1>\n  <hr />\n   <h3>abc --- {{ username }}</h3>\n  <hr />\n  <p>count值是：{{ count }}</p>\n  <button @click=\"addCount\">+1</button> \n</template>\n```\n\n```html\n<!--在 <script> 节点中封装组件的 JavaScript 业务逻辑-->\n<script>\nexport default{    \n  name:'MyApp',   //组件名称\n  data(){      //组件数据\n    return {                                 <!--组件相关的数据、方法都需要定义到 \n                                             //export default 所导出的对象中-->\n      count:0\n    }\n  },\n  methods:{     //处理函数\n    addCount(){\n      this.count++\n    }\n  }\n  \n}  \n</script>\n```\n\n```html\n<!--在 <style> 节点中编写样式美化当前组件的 UI 结构\n\n其中 <style> 标签上的 lang=\"css\" 属性是可选的，它表示所使用的样式语言。默认只支持普通的 css 语法，可 选值还有 less、scss 等。-->\n<style lang='css'>\n  h1{\n    font-weight: normal;\n  }\n</style>\n```\n\n**组件的基本使用**\n\n组件之间可以进行相互的引用，vue 中组件的引用原则：先注册后使用。\n\nvue 中注册组件的方式分为“全局注册”和“局部注册”两种\n\n```java\nimport {creatApp} from 'vue'\nimport App from './App.vue'\n//1、导入Test组件\nimport Test from './components/MyTest.vue'\nconst app = createApp(App)\n//2、调用app实例component('my-test',Test)\n```\n\n```html\n//在main.js中，注册my-test全局组件\nspa_app.component('my-test',Test)\n<!-- 在其他组件中，直接以标签形式，使用刚才注册的全局组件 -->\n<template>\n\t<my-test></my-test>\n</template>\n```\n\n```html\n<template>\n  <h1>这是App组件</h1>\n  <my-test></my-test>\n\t<my-search></my-search>\n</template>\n\n<script>\nimport Search from './components/MySearch.vue'\n  export default {\n    components:{\n      'my-search': Search,\n    }\n  }\n</script>\n```\n\n防止组件之间的样式冲突：style 节点的 scoped 属性\n\nprops 是组件的自定义属性，组件的使用者可以通过 props 把数据传递到子组件内部，供子组件内部进行使 用。\n\n作用：父组件通过 props 向子组件传递要展示的数据。     好处：提高了组件的复用性。\n\n```html\n<my-article tltle='vue' author='my' pubTime='3.25'></my-article>\n<template>\n  <div>\n    <h3>标题：{{title}}</h3>\n    <h5>作者：{{author}}</h5>\n    <h6>发布时间：{{pubTime}}</h6>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'MyArticle',\n  // 外界可以传递指定的数据，到当前的组件中\n  props: ['title', 'author', 'pubTime']\n}\n</script>\n```\n\n通过 v-bind 属性绑定指令，为元 素动态绑定prop值、 class 属性的值和行内的 style 样式。\n\n**props 验证**\n\n在封装组件时对外界传递过来的 props 数据进行合法性的校验，从而防止数据不合法的问题。\n\n```html\n<script>\nexport default {\n\tprpos:{\n\t\tpropA:{\n\t\t\ttype:String,\n\t\t\trequired:true\n\t\t\tdefault:'abc'\n\t\t},\n\t\tpropB:[String,Number],\n\t\tpropC:{\n\t\t\tvalidator(value){\n\t\t\t\treturn ['success','warning','danger'],indexOf(value) !== -1\n\t\t\t}\n\t\t}\n\t}\n}\n</script>\n```\n\n**计算属性**\n\n计算属性本质上就是一个 function 函数，它可以实时监听 data 中数据的变化，并 return 一个计算后的新值， 供组件渲染 DOM 时使用。计算属性需要以 function 函数的形式声明到组件的 computed 选项中。\n\n```html\n<input tvpe=\"text\" v-model.number=\"count\" />\n<p>{{count}}了乘以2的值为：{{ plus }} </p>\n\n data() {\n\treturn { count: 1 }\n},\n computed: {\n\t\tplus() { \n\t\t\treturn this.count * 2\n\t\t},\n}\n```\n\n相对于方法来说，计算属性会缓存计算的结果，只有计算属性的依赖项发生变化时，才会重新进行运算。因此 计算属性的性能更好。\n\n**自定义事件**\n\n3 个使用步骤           在封装组件时： ① 声明自定义事件 ② 触发自定义事件         在使用组件时： ③ 监听自定义事件\n\n```html \n<template>\n\t<button @click='onBtnClick'>+1</button>\n</template>\n<script>\nexport default {\n  emits:['change'],      //自定义事件必须事先在 emits 节点中声明\n  methods:{\n    onBtnClick(){\n      //自定义事件可以通过 this.$emit('自定义事件的名称') 方法进行触发，可以通过第 2 个参数为自定义事件传参\n      this.$emit('change',this.count)\n    }\n  }\n}\n</script>\n```\n\n**组件上的 v-model**\n\n父组件通过 v-bind: 属性绑定的形式，把数据传递给子组件                  子组件中，通过 props 接收父组件传递过来的数据\n\n在 v-bind: 指令之前添加 v-model 指令                                         在子组件中声明 emits 自定义事件，格式为 update:xxx\n\n调用 $emit() 触发自定义事件，更新父组件中的数据\n","tags":["vue","前端"],"categories":["技术"]},{"title":"明天会更好       吗？","slug":"明天会更好 吗？","url":"/2022/05/07/ming-tian-hui-geng-hao-ma/","content":"\n一、现状\n易中天有言“现状不可描述“，那我冒着风险简单描述一下。\n房地产：头部企业接连债务违约，房价开始下跌，成交量萎靡，人均房产面积数量是发达国家的几倍，法拍房数量指数增加。\n制造业：本来就没有核心技术，赚个加工费。现在海外订单大量转移到东南亚印度。同时原料成本暴增，侵蚀现金流，挤压利润空间。\n物流：2021年商用车销量低迷，车辆金融大面积违约。现在全国大量高速路口关闭，城市之间层层关卡，高速出口24小时大堵车。\n餐饮类服务业：为底层劳动力提供大量工作岗位的餐饮服务业，疫情管控的城市不能堂食或者不能营业，大量开除员工，一个月的租金可能会亏完一年的利润。\n教培行业：曾经为大学生提供巨量工作岗位的行业，现状你懂的。\n旅游业：你懂的。\n互联网：美股暴跌，退市风险、严卡上市导致融资渠道收紧，没钱可烧了。同时互联网技术应用成熟，产品内卷，审查趋严。\n消费电子行业：以手机为例，人均换机时间曾长，红米等平价机型销量上升。\n建筑施工：房建项目萎缩，账期在原有基础上进一步增加，基建项目政策不清晰，两者都受疫情管控影响，开工率低。\n能源、原料：石油价格十年新高，带动其他原材料价格暴涨。\n农牧渔业：受外国战争影响，粮食化肥价格暴涨，受疫情管控影响，生鲜蔬菜价格上涨，物流受限导致销量降低。\n人口：增长数量创新低，今年可能负增长。\n\n二、未来（个人预测）\n一线城市外，房价下跌，断供现象常见。\n海外订单转移，产业链头部外企撤离，国内工厂内卷，厂多单少。\n银行坏账增加，贷款审批更加严格。\n至少一年内疫情反复，管控政策无法解除。\n新增人口数量进一步降低，进入负增长时代。\n学生越来越少，学校和教师数量过剩。\n科研：国际关系恶化可能导致科研合作停止，海外发文章越来越难。\n工业品价格上涨，受物流影响，短期内江浙沪的超市可能会出现部分产品缺货现象。\n\n三、建议\n不要贷款或者借钱买房。\n多囤积，囤积物资、金钱或者发展机会，例如多学习其他行业的技能。\n慎重跳槽，不要创业，减少投资，有条件的话尽量考公务员或者事业单位。\n少生娃。\n关爱身边人，为自己利益考量的时候尽量不要损害别人的利益，无法对他人苦难感同身受的时候，尽量不要指责他人矫情、装抑郁、甚至是给境外势力递刀子。\n学习了解基本求生技能。\n秩序崩塌的时候，紧急时刻，回归野蛮。\n\n四、逼逼叨环节\n作为90后，我生长在经济高速增长的年代，潜意识里觉得这个世界就应该这样子，社会越来越发达，父母的工资越来越高，所有人的生活越来越好。\n改革开放如火如荼的时候，没有人会想起，苏联和朝鲜也曾经是工业国家，曾经有过良好的物质生活条件。\n家长们都是认为孩子努力就能考上大学，考上大学就有体面的工作，就能在大城市扎根生活，成为城里人。\n我们上学读书的时候，总感觉天生我材必有用，无论从前什么行业，将来都能出人头地，大学毕业才知道什么是“生化环材”天坑专业，土木机械这种曾经挤破头的专业也成了劝退专业。\n以前总是习惯了房价上涨，期待着自己有朝一日也借钱上车，坐享一年增值几十万的时代红利。\n无法想象经济负增长的世界，就像无法想象手机摄像头像素、屏幕分辨率停滞增长。\n\n**我对未来仍然有信心**，但是至少两三年内，大家日子都不会很好过。就好像曾经的下岗潮，不影响历史的车轮滚滚前行，但是给无数人留下了苦涩的记忆，也有人撑不下去死在寒冬里。\n\n如果运气好的话，一年后所有上述不利情况都有所缓解，然后百废俱兴。\n如果运气不好，可能要10年后从头再来。\n时代的一粒微尘，落到一个人的头上就是一座大山。\n很不幸，我们赶上了。\n很幸运，我们现在赶上了，不是十年前不是十年后，我们如今年轻力壮，抗得住一些磨难。\n\n我们已经一只脚迈进了“乱纪元”。","tags":["历史","时政"],"categories":["杂谈"]}]